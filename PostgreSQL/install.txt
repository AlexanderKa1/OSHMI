# References
# https://www.openscg.com/bigsql/package-manager.jsp/
# https://stackoverflow.com/questions/36571883/how-to-set-proxy-from-command-line-windows-7


# Open Powershell with admin rights.

# if you dont't have a proxy delete this part of the command below
# (New-Object System.Net.WebClient).Proxy.Credentials =  [System.Net.CredentialCache]::DefaultNetworkCredentials

# exec this to install with proxy 
@powershell -NoProfile -ExecutionPolicy unrestricted -Command "(New-Object System.Net.WebClient).Proxy.Credentials =  [System.Net.CredentialCache]::DefaultNetworkCredentials; iex ((new-object net.webclient).DownloadString('https://s3.amazonaws.com/pgcentral/install.ps1'))"

# without proxy
@powershell -NoProfile -ExecutionPolicy unrestricted -Command "iex ((new-object net.webclient).DownloadString('https://s3.amazonaws.com/pgcentral/install.ps1'))"


cd bigsql
pgc install pg10
pgc init pg10

# default password set as: oshmi, user: postgres

cd pg10
pg10-env.bat

cd ..

pgc start
pgc stop
cd ..\timescaledb
setup
cd ..
pgc start
pgc status

REM change Windows codepage to match PostgreSQL database
SET PGCLIENTENCODING=latin1
CHCP 1252

# connect
psql -h 127.0.0.1 -U postgres -W

-- create oshmi database 
create database oshmi template=template0 encoding=latin1;
-- Connect to the database
\c oshmi
-- Extend the database with TimescaleDB
CREATE EXTENSION IF NOT EXISTS timescaledb CASCADE;

\q

psql -h 127.0.0.1 -U postgres -d oshmi -W

-- create tables
-- DROP TABLE soe;
CREATE TABLE soe (
   NPONTO Integer NOT NULL,
   DATA BIGINT NOT NULL,
   HORA Integer NOT NULL,
   MSEC Integer NOT NULL,
   UTR Integer NOT NULL,
   ESTADO Integer NOT NULL,
   RECON Integer NOT NULL,
   TS BIGINT NOT NULL,
   PRIMARY KEY ( NPONTO, DATA, HORA, MSEC )
   );
CREATE INDEX ind_dhms on soe ( DATA, HORA, MSEC );
CREATE INDEX ind_ts on soe ( TS );
CREATE INDEX ind_recon on soe ( RECON );

-- timescaledb hypertable, partitioned by day
SELECT create_hypertable('soe', 'data', chunk_time_interval=>86400);

-- DROP TABLE hist;
CREATE TABLE hist (
   NPONTO Integer NOT NULL,
   VALOR Real NOT NULL,
   FLAGS Integer NOT NULL,
   DATA BIGINT NOT NULL,
   PRIMARY KEY (NPONTO, DATA)
   );
-- CREATE INDEX ind_data on hist ( DATA );

-- timescaledb hypertable, partitioned by day
SELECT create_hypertable('hist', 'data', chunk_time_interval=>86400);

-- DROP TABLE dumpdb;
CREATE TABLE dumpdb (
   NPONTO Integer Primary Key NOT NULL,
   ID Text,
   DESCRICAO Text,
   VALOR Real,
   FLAGS Integer,
   LIMS Real,
   LIMI Real,
   HISTER Real,
   DATA BIGINT,
   HORA Integer,
   TS BIGINT,
   ALRIN Integer,
   VLRINI Real,
   HISTOR Integer,
   BMORTA Real,
   PERIODO Integer,
   TIPO Text,
   UNIDADE Text,
   ESTON Text,
   ESTOFF Text,
   SUPCMD Integer,
   TIMEOUT Integer,
   ANOTACAO Text,
   ESTACAO text,
   ESTALM integer,
   PRIOR integer,
   -- from here extends original OSHMI SQLITE DB
   MODULO Text default '', -- seconday grouping (bay)
   DESCR_CURTA Text default '',
   DESCR_LONGA Text default '',
   NOME_LOCAL Text default '',
   LATITUDE Real default 0 ,
   LONGITUDE Real default 0,
   ORIGEM integer default 0,
   LIMSS Real default 999999999,
   LIMII Real default -999999999,
   LIMSSS Real default 999999999,
   LIMIII Real default -999999999   
   );
CREATE UNIQUE INDEX ind_id on dumpdb ( ID );
CREATE INDEX ind_estacao on dumpdb ( ESTACAO );
CREATE INDEX ind_tipo on dumpdb ( TIPO );
CREATE INDEX ind_supcmd on dumpdb ( SUPCMD );
CREATE INDEX ind_prior on dumpdb ( PRIOR );

-- to be filled by trigger on hist
-- DROP TABLE val_tr;
CREATE TABLE val_tr (
  NPONTO integer NOT NULL,
  VALOR Real NOT NULL,
  FLAGS integer NOT NULL,
  DATA BIGINT NOT NULL, -- acquisition timestamp
  TS BIGINT, -- tuple update timestamp
  DATA_ALT BIGINT NOT NULL default 0, -- changed value timestamp
  PRIMARY KEY (NPONTO)
);

-- trigger to update val_tr from hist
DROP TRIGGER afterHist ON hist;
DROP FUNCTION val_tr_proc;

CREATE OR REPLACE FUNCTION val_tr_proc()
RETURNS trigger AS $afterHist$
BEGIN
    IF (TG_OP = 'DELETE') THEN
	  DELETE FROM val_tr WHERE NPONTO = OLD.NPONTO;
	ELSIF (TG_OP = 'UPDATE') THEN
	  INSERT INTO val_tr SELECT NEW.NPONTO, NEW.VALOR, NEW.FLAGS, NEW.DATA, extract(epoch from now()), 0 
	    ON CONFLICT (NPONTO) DO UPDATE SET VALOR=NEW.VALOR, FLAGS=NEW.FLAGS, DATA=NEW.DATA, TS=extract(epoch from now()), DATA_ALT=0 WHERE val_tr.nponto=NEW.nponto;
	ELSIF (TG_OP = 'INSERT') THEN
	  INSERT INTO val_tr SELECT NEW.NPONTO, NEW.VALOR, NEW.FLAGS, NEW.DATA, extract(epoch from now()), 0 
	    ON CONFLICT (NPONTO) DO UPDATE SET VALOR=NEW.VALOR, FLAGS=NEW.FLAGS, DATA=NEW.DATA, TS=extract(epoch from now()), DATA_ALT=0 WHERE val_tr.nponto=NEW.nponto;
	END IF;
	RETURN NULL;	
END;
$afterHist$ LANGUAGE plpgsql;

-- trigger when hist written, update val_tr
CREATE TRIGGER afterHist
AFTER INSERT OR UPDATE OR DELETE ON hist
FOR EACH ROW
EXECUTE PROCEDURE val_tr_proc();

-- trigger to update dumpdb.modulo
DROP TRIGGER afterDumpdb ON dumpdb;
DROP FUNCTION dumpdb_proc;

-- trigger procedure
CREATE OR REPLACE FUNCTION dumpdb_proc()
RETURNS trigger AS $afterDumpdb$
BEGIN
  IF (TG_OP = 'INSERT') THEN
          NEW.MODULO = left( NEW.DESCRICAO, position ('~' in NEW.DESCRICAO )-1);
	ELSIF (TG_OP = 'UPDATE') THEN
          NEW.MODULO = left( NEW.DESCRICAO, position ('~' in NEW.DESCRICAO )-1);
	END IF;
	RETURN NEW;	
END;
$afterDumpdb$ LANGUAGE plpgsql;

-- trigger when dumpdb written, update dumpdb.modulo
DROP TRIGGER afterDumpdb ON dumpdb;
CREATE TRIGGER afterDumpdb
BEFORE INSERT OR UPDATE ON dumpdb
FOR EACH ROW
EXECUTE PROCEDURE dumpdb_proc();

-- HELPFUL VIEWS

DROP VIEW catalog;
CREATE VIEW catalog
AS 
SELECT 
       d.ID AS TAG, 
       d.ESTACAO || ' ' || d.DESCRICAO AS DESCRIPTION, 
       d.TIPO AS TYPE_ANADIG,
       d.UNIDADE AS UNIT,
       d.NPONTO AS POINT_KEY,
       d.ESTACAO AS GROUP_MAIN, 
       d.MODULO AS GROUP_SECONDARY,
       CASE WHEN d.DESCR_CURTA='' THEN d.DESCRICAO ELSE d.DESCR_CURTA END as DESCR_SHORT,
       CASE WHEN d.DESCR_LONGA='' THEN (d.ESTACAO || ' ' || d.DESCRICAO) ELSE d.DESCR_LONGA END as DESCR_LONG,
       d.NOME_LOCAL AS LOCATION,
       d.LATITUDE AS LATITUDE,
       d.LONGITUDE AS LONGITUDE,
       d.ESTOFF AS STATE_OFF,
       d.ESTON AS STATE_ON,
       d.ANOTACAO AS COMMENTS,
       d.LIMI AS LO_LIM,
       d.LIMS AS HI_LIM,
       d.LIMII AS LOLO_LIM,
       d.LIMSS AS HIHI_LIM,
       d.LIMIII AS LOLOLO_LIM,
       d.LIMSSS AS HIHIHI_LIM,
       d.ESTALM AS ALARM_ST,
       d.TS AS UPDATE_TIMESTAMP

FROM DUMPDB d
ORDER BY d.ID
;

DROP VIEW realtime_data;
CREATE VIEW realtime_data
AS 
SELECT 
       CASE WHEN d.TIPO='D' THEN ( CASE WHEN v.FLAGS&1=1 THEN 0 ELSE 1 END ) ELSE v.VALOR END AS VALUE,
       CASE WHEN d.TIPO='D' THEN ( CASE WHEN v.FLAGS&1=1 THEN d.ESTOFF ELSE d.ESTON END ) ELSE v.VALOR || ' ' || d.UNIDADE END AS STATUS,
       CASE WHEN (v.FLAGS & 128) > 0 THEN 1 ELSE 0 END AS FAILED, 
       v.FLAGS,
       to_timestamp(v.DATA) AS LOCAL_TIME,
       v.DATA AS UNIX_TIMESTAMP,
       timezone('UTC', to_timestamp(v.DATA)) as GMT_TIME,
	   
       d.ID AS TAG, 
       d.ESTACAO || ' ' || d.DESCRICAO AS DESCRIPTION, 
       d.TIPO AS TYPE_ANADIG,
       d.UNIDADE AS UNIT,
       v.NPONTO AS POINT_KEY,
       d.ESTACAO AS GROUP_MAIN, 
       d.MODULO AS GROUP_SECONDARY,
       CASE WHEN d.DESCR_CURTA='' THEN d.DESCRICAO ELSE d.DESCR_CURTA END AS DESCR_SHORT,
       CASE WHEN d.DESCR_LONGA='' THEN d.ESTACAO || ' ' || d.DESCRICAO ELSE d.DESCR_LONGA END AS DESCR_LONG,
       d.NOME_LOCAL AS LOCATION,
       d.LATITUDE AS LATITUDE,
       d.LONGITUDE AS LONGITUDE,
       d.ESTOFF AS STATE_OFF,
       d.ESTON AS STATE_ON,
       d.ANOTACAO AS COMMENTS,
       d.LIMI AS LO_LIM,
       d.LIMS AS HI_LIM,
       d.LIMII AS LOLO_LIM,
       d.LIMSS AS HIHI_LIM,
       d.LIMIII AS LOLOLO_LIM,
       d.LIMSSS AS HIHIHI_LIM,
       d.ESTALM AS ALARM_ST

FROM val_tr v 
JOIN dumpdb d ON v.NPONTO = d.NPONTO AND d.ID != ''
ORDER BY d.ID
;

DROP VIEW historical_data;
CREATE VIEW historical_data
AS 
SELECT  
       CASE WHEN d.TIPO='D' THEN ( CASE WHEN v.FLAGS&1=1 THEN 0 ELSE 1 END ) ELSE v.VALOR END AS VALUE,
       CASE WHEN d.TIPO='D' THEN ( CASE WHEN v.FLAGS&1=1 THEN d.ESTOFF ELSE d.ESTON END ) ELSE v.VALOR || ' ' || d.UNIDADE END AS STATUS,
       CASE WHEN (v.FLAGS & 128) > 0 THEN 1 ELSE 0 END AS FAILED, 
       v.FLAGS,
       to_timestamp(v.DATA) AS LOCAL_TIME,
       v.DATA AS UNIX_TIMESTAMP,
       timezone('UTC', to_timestamp(v.DATA)) as GMT_TIME,

       d.ID AS TAG, 
       d.ESTACAO || ' ' || d.DESCRICAO AS DESCRIPTION, 
       d.TIPO AS TYPE_ANADIG,
       d.UNIDADE AS UNIT,
       v.NPONTO AS POINT_KEY,
       d.ESTACAO AS GROUP_MAIN, 
       d.MODULO AS GROUP_SECONDARY,
       CASE WHEN d.DESCR_CURTA='' THEN d.DESCRICAO ELSE d.DESCR_CURTA END AS DESCR_SHORT,
       CASE WHEN d.DESCR_LONGA='' THEN d.ESTACAO || ' ' || d.DESCRICAO ELSE d.DESCR_LONGA END AS DESCR_LONG,
       d.NOME_LOCAL AS LOCATION,
       d.LATITUDE AS LATITUDE,
       d.LONGITUDE AS LONGITUDE,
       d.ESTOFF AS STATE_OFF,
       d.ESTON AS STATE_ON,
       d.ANOTACAO AS COMMENTS,
       d.LIMI AS LO_LIM,
       d.LIMS AS HI_LIM,
       d.LIMII AS LOLO_LIM,
       d.LIMSS AS HIHI_LIM,
       d.LIMIII AS LOLOLO_LIM,
       d.LIMSSS AS HIHIHI_LIM,
       d.ESTALM AS ALARM_ST

FROM hist v 
JOIN dumpdb d on v.NPONTO = d.NPONTO and d.ID != ''
ORDER BY d.ID, UNIX_TIMESTAMP DESC
-- limit 10000 -- in case of low performance!
;


